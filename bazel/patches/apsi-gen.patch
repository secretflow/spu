diff --git b/common/apsi/psi_params_generated.h b/common/apsi/psi_params_generated.h
new file mode 100644
index 0000000..ed2837b
--- /dev/null
+++ b/common/apsi/psi_params_generated.h
@@ -0,0 +1,310 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_PSIPARAMS_APSI_FBS_H_
+#define FLATBUFFERS_GENERATED_PSIPARAMS_APSI_FBS_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+// Ensure the included flatbuffers.h is the same version as when this file was
+// generated, otherwise it may not be compatible.
+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
+              FLATBUFFERS_VERSION_MINOR == 3 &&
+              FLATBUFFERS_VERSION_REVISION == 3,
+             "Non-compatible flatbuffers version included");
+
+namespace apsi {
+namespace fbs {
+
+struct ItemParams;
+
+struct TableParams;
+
+struct QueryParams;
+struct QueryParamsBuilder;
+
+struct SEALParams;
+struct SEALParamsBuilder;
+
+struct PSIParams;
+struct PSIParamsBuilder;
+
+FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ItemParams FLATBUFFERS_FINAL_CLASS {
+ private:
+  uint32_t felts_per_item_;
+
+ public:
+  ItemParams()
+      : felts_per_item_(0) {
+  }
+  ItemParams(uint32_t _felts_per_item)
+      : felts_per_item_(::flatbuffers::EndianScalar(_felts_per_item)) {
+  }
+  uint32_t felts_per_item() const {
+    return ::flatbuffers::EndianScalar(felts_per_item_);
+  }
+};
+FLATBUFFERS_STRUCT_END(ItemParams, 4);
+
+FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TableParams FLATBUFFERS_FINAL_CLASS {
+ private:
+  uint32_t table_size_;
+  uint32_t max_items_per_bin_;
+  uint32_t hash_func_count_;
+
+ public:
+  TableParams()
+      : table_size_(0),
+        max_items_per_bin_(0),
+        hash_func_count_(0) {
+  }
+  TableParams(uint32_t _table_size, uint32_t _max_items_per_bin, uint32_t _hash_func_count)
+      : table_size_(::flatbuffers::EndianScalar(_table_size)),
+        max_items_per_bin_(::flatbuffers::EndianScalar(_max_items_per_bin)),
+        hash_func_count_(::flatbuffers::EndianScalar(_hash_func_count)) {
+  }
+  uint32_t table_size() const {
+    return ::flatbuffers::EndianScalar(table_size_);
+  }
+  uint32_t max_items_per_bin() const {
+    return ::flatbuffers::EndianScalar(max_items_per_bin_);
+  }
+  uint32_t hash_func_count() const {
+    return ::flatbuffers::EndianScalar(hash_func_count_);
+  }
+};
+FLATBUFFERS_STRUCT_END(TableParams, 12);
+
+struct QueryParams FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef QueryParamsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_PS_LOW_DEGREE = 4,
+    VT_QUERY_POWERS = 6
+  };
+  uint32_t ps_low_degree() const {
+    return GetField<uint32_t>(VT_PS_LOW_DEGREE, 0);
+  }
+  const ::flatbuffers::Vector<uint32_t> *query_powers() const {
+    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_QUERY_POWERS);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint32_t>(verifier, VT_PS_LOW_DEGREE, 4) &&
+           VerifyOffset(verifier, VT_QUERY_POWERS) &&
+           verifier.VerifyVector(query_powers()) &&
+           verifier.EndTable();
+  }
+};
+
+struct QueryParamsBuilder {
+  typedef QueryParams Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_ps_low_degree(uint32_t ps_low_degree) {
+    fbb_.AddElement<uint32_t>(QueryParams::VT_PS_LOW_DEGREE, ps_low_degree, 0);
+  }
+  void add_query_powers(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> query_powers) {
+    fbb_.AddOffset(QueryParams::VT_QUERY_POWERS, query_powers);
+  }
+  explicit QueryParamsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<QueryParams> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<QueryParams>(end);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<QueryParams> CreateQueryParams(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint32_t ps_low_degree = 0,
+    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> query_powers = 0) {
+  QueryParamsBuilder builder_(_fbb);
+  builder_.add_query_powers(query_powers);
+  builder_.add_ps_low_degree(ps_low_degree);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<QueryParams> CreateQueryParamsDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint32_t ps_low_degree = 0,
+    const std::vector<uint32_t> *query_powers = nullptr) {
+  auto query_powers__ = query_powers ? _fbb.CreateVector<uint32_t>(*query_powers) : 0;
+  return apsi::fbs::CreateQueryParams(
+      _fbb,
+      ps_low_degree,
+      query_powers__);
+}
+
+struct SEALParams FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef SEALParamsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA = 4
+  };
+  const ::flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SEALParamsBuilder {
+  typedef SEALParams Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(SEALParams::VT_DATA, data);
+  }
+  explicit SEALParamsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<SEALParams> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<SEALParams>(end);
+    fbb_.Required(o, SEALParams::VT_DATA);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<SEALParams> CreateSEALParams(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
+  SEALParamsBuilder builder_(_fbb);
+  builder_.add_data(data);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<SEALParams> CreateSEALParamsDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<uint8_t> *data = nullptr) {
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  return apsi::fbs::CreateSEALParams(
+      _fbb,
+      data__);
+}
+
+struct PSIParams FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef PSIParamsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_VERSION = 4,
+    VT_ITEM_PARAMS = 6,
+    VT_TABLE_PARAMS = 8,
+    VT_QUERY_PARAMS = 10,
+    VT_SEAL_PARAMS = 12
+  };
+  uint32_t version() const {
+    return GetField<uint32_t>(VT_VERSION, 0);
+  }
+  const apsi::fbs::ItemParams *item_params() const {
+    return GetStruct<const apsi::fbs::ItemParams *>(VT_ITEM_PARAMS);
+  }
+  const apsi::fbs::TableParams *table_params() const {
+    return GetStruct<const apsi::fbs::TableParams *>(VT_TABLE_PARAMS);
+  }
+  const apsi::fbs::QueryParams *query_params() const {
+    return GetPointer<const apsi::fbs::QueryParams *>(VT_QUERY_PARAMS);
+  }
+  const apsi::fbs::SEALParams *seal_params() const {
+    return GetPointer<const apsi::fbs::SEALParams *>(VT_SEAL_PARAMS);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
+           VerifyField<apsi::fbs::ItemParams>(verifier, VT_ITEM_PARAMS, 4) &&
+           VerifyField<apsi::fbs::TableParams>(verifier, VT_TABLE_PARAMS, 4) &&
+           VerifyOffset(verifier, VT_QUERY_PARAMS) &&
+           verifier.VerifyTable(query_params()) &&
+           VerifyOffsetRequired(verifier, VT_SEAL_PARAMS) &&
+           verifier.VerifyTable(seal_params()) &&
+           verifier.EndTable();
+  }
+};
+
+struct PSIParamsBuilder {
+  typedef PSIParams Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_version(uint32_t version) {
+    fbb_.AddElement<uint32_t>(PSIParams::VT_VERSION, version, 0);
+  }
+  void add_item_params(const apsi::fbs::ItemParams *item_params) {
+    fbb_.AddStruct(PSIParams::VT_ITEM_PARAMS, item_params);
+  }
+  void add_table_params(const apsi::fbs::TableParams *table_params) {
+    fbb_.AddStruct(PSIParams::VT_TABLE_PARAMS, table_params);
+  }
+  void add_query_params(::flatbuffers::Offset<apsi::fbs::QueryParams> query_params) {
+    fbb_.AddOffset(PSIParams::VT_QUERY_PARAMS, query_params);
+  }
+  void add_seal_params(::flatbuffers::Offset<apsi::fbs::SEALParams> seal_params) {
+    fbb_.AddOffset(PSIParams::VT_SEAL_PARAMS, seal_params);
+  }
+  explicit PSIParamsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<PSIParams> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<PSIParams>(end);
+    fbb_.Required(o, PSIParams::VT_SEAL_PARAMS);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<PSIParams> CreatePSIParams(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint32_t version = 0,
+    const apsi::fbs::ItemParams *item_params = nullptr,
+    const apsi::fbs::TableParams *table_params = nullptr,
+    ::flatbuffers::Offset<apsi::fbs::QueryParams> query_params = 0,
+    ::flatbuffers::Offset<apsi::fbs::SEALParams> seal_params = 0) {
+  PSIParamsBuilder builder_(_fbb);
+  builder_.add_seal_params(seal_params);
+  builder_.add_query_params(query_params);
+  builder_.add_table_params(table_params);
+  builder_.add_item_params(item_params);
+  builder_.add_version(version);
+  return builder_.Finish();
+}
+
+inline const apsi::fbs::PSIParams *GetPSIParams(const void *buf) {
+  return ::flatbuffers::GetRoot<apsi::fbs::PSIParams>(buf);
+}
+
+inline const apsi::fbs::PSIParams *GetSizePrefixedPSIParams(const void *buf) {
+  return ::flatbuffers::GetSizePrefixedRoot<apsi::fbs::PSIParams>(buf);
+}
+
+inline bool VerifyPSIParamsBuffer(
+    ::flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<apsi::fbs::PSIParams>(nullptr);
+}
+
+inline bool VerifySizePrefixedPSIParamsBuffer(
+    ::flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<apsi::fbs::PSIParams>(nullptr);
+}
+
+inline void FinishPSIParamsBuffer(
+    ::flatbuffers::FlatBufferBuilder &fbb,
+    ::flatbuffers::Offset<apsi::fbs::PSIParams> root) {
+  fbb.Finish(root);
+}
+
+inline void FinishSizePrefixedPSIParamsBuffer(
+    ::flatbuffers::FlatBufferBuilder &fbb,
+    ::flatbuffers::Offset<apsi::fbs::PSIParams> root) {
+  fbb.FinishSizePrefixed(root);
+}
+
+}  // namespace fbs
+}  // namespace apsi
+
+#endif  // FLATBUFFERS_GENERATED_PSIPARAMS_APSI_FBS_H_
diff --git b/sender/apsi/bin_bundle_generated.h b/sender/apsi/bin_bundle_generated.h
new file mode 100644
index 0000000..e821e33
--- /dev/null
+++ b/sender/apsi/bin_bundle_generated.h
@@ -0,0 +1,490 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_BINBUNDLE_APSI_FBS_H_
+#define FLATBUFFERS_GENERATED_BINBUNDLE_APSI_FBS_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+// Ensure the included flatbuffers.h is the same version as when this file was
+// generated, otherwise it may not be compatible.
+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
+              FLATBUFFERS_VERSION_MINOR == 3 &&
+              FLATBUFFERS_VERSION_REVISION == 3,
+             "Non-compatible flatbuffers version included");
+
+namespace apsi {
+namespace fbs {
+
+struct FEltArray;
+struct FEltArrayBuilder;
+
+struct FEltMatrix;
+struct FEltMatrixBuilder;
+
+struct Plaintext;
+struct PlaintextBuilder;
+
+struct BatchedPlaintextPolyn;
+struct BatchedPlaintextPolynBuilder;
+
+struct BinBundleCache;
+struct BinBundleCacheBuilder;
+
+struct BinBundle;
+struct BinBundleBuilder;
+
+struct FEltArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef FEltArrayBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FELTS = 4
+  };
+  const ::flatbuffers::Vector<uint64_t> *felts() const {
+    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_FELTS);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_FELTS) &&
+           verifier.VerifyVector(felts()) &&
+           verifier.EndTable();
+  }
+};
+
+struct FEltArrayBuilder {
+  typedef FEltArray Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_felts(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> felts) {
+    fbb_.AddOffset(FEltArray::VT_FELTS, felts);
+  }
+  explicit FEltArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<FEltArray> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<FEltArray>(end);
+    fbb_.Required(o, FEltArray::VT_FELTS);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<FEltArray> CreateFEltArray(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> felts = 0) {
+  FEltArrayBuilder builder_(_fbb);
+  builder_.add_felts(felts);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<FEltArray> CreateFEltArrayDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<uint64_t> *felts = nullptr) {
+  auto felts__ = felts ? _fbb.CreateVector<uint64_t>(*felts) : 0;
+  return apsi::fbs::CreateFEltArray(
+      _fbb,
+      felts__);
+}
+
+struct FEltMatrix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef FEltMatrixBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ROWS = 4
+  };
+  const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltArray>> *rows() const {
+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltArray>> *>(VT_ROWS);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_ROWS) &&
+           verifier.VerifyVector(rows()) &&
+           verifier.VerifyVectorOfTables(rows()) &&
+           verifier.EndTable();
+  }
+};
+
+struct FEltMatrixBuilder {
+  typedef FEltMatrix Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_rows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltArray>>> rows) {
+    fbb_.AddOffset(FEltMatrix::VT_ROWS, rows);
+  }
+  explicit FEltMatrixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<FEltMatrix> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<FEltMatrix>(end);
+    fbb_.Required(o, FEltMatrix::VT_ROWS);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<FEltMatrix> CreateFEltMatrix(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltArray>>> rows = 0) {
+  FEltMatrixBuilder builder_(_fbb);
+  builder_.add_rows(rows);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<FEltMatrix> CreateFEltMatrixDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<::flatbuffers::Offset<apsi::fbs::FEltArray>> *rows = nullptr) {
+  auto rows__ = rows ? _fbb.CreateVector<::flatbuffers::Offset<apsi::fbs::FEltArray>>(*rows) : 0;
+  return apsi::fbs::CreateFEltMatrix(
+      _fbb,
+      rows__);
+}
+
+struct Plaintext FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef PlaintextBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA = 4
+  };
+  const ::flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+};
+
+struct PlaintextBuilder {
+  typedef Plaintext Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(Plaintext::VT_DATA, data);
+  }
+  explicit PlaintextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<Plaintext> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<Plaintext>(end);
+    fbb_.Required(o, Plaintext::VT_DATA);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<Plaintext> CreatePlaintext(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
+  PlaintextBuilder builder_(_fbb);
+  builder_.add_data(data);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<Plaintext> CreatePlaintextDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<uint8_t> *data = nullptr) {
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  return apsi::fbs::CreatePlaintext(
+      _fbb,
+      data__);
+}
+
+struct BatchedPlaintextPolyn FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef BatchedPlaintextPolynBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_COEFFS = 4
+  };
+  const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::Plaintext>> *coeffs() const {
+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::Plaintext>> *>(VT_COEFFS);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_COEFFS) &&
+           verifier.VerifyVector(coeffs()) &&
+           verifier.VerifyVectorOfTables(coeffs()) &&
+           verifier.EndTable();
+  }
+};
+
+struct BatchedPlaintextPolynBuilder {
+  typedef BatchedPlaintextPolyn Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_coeffs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::Plaintext>>> coeffs) {
+    fbb_.AddOffset(BatchedPlaintextPolyn::VT_COEFFS, coeffs);
+  }
+  explicit BatchedPlaintextPolynBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<BatchedPlaintextPolyn> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<BatchedPlaintextPolyn>(end);
+    fbb_.Required(o, BatchedPlaintextPolyn::VT_COEFFS);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<BatchedPlaintextPolyn> CreateBatchedPlaintextPolyn(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::Plaintext>>> coeffs = 0) {
+  BatchedPlaintextPolynBuilder builder_(_fbb);
+  builder_.add_coeffs(coeffs);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<BatchedPlaintextPolyn> CreateBatchedPlaintextPolynDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<::flatbuffers::Offset<apsi::fbs::Plaintext>> *coeffs = nullptr) {
+  auto coeffs__ = coeffs ? _fbb.CreateVector<::flatbuffers::Offset<apsi::fbs::Plaintext>>(*coeffs) : 0;
+  return apsi::fbs::CreateBatchedPlaintextPolyn(
+      _fbb,
+      coeffs__);
+}
+
+struct BinBundleCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef BinBundleCacheBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FELT_MATCHING_POLYNS = 4,
+    VT_BATCHED_MATCHING_POLYN = 6,
+    VT_FELT_INTERP_POLYNS = 8,
+    VT_BATCHED_INTERP_POLYNS = 10
+  };
+  const apsi::fbs::FEltMatrix *felt_matching_polyns() const {
+    return GetPointer<const apsi::fbs::FEltMatrix *>(VT_FELT_MATCHING_POLYNS);
+  }
+  const apsi::fbs::BatchedPlaintextPolyn *batched_matching_polyn() const {
+    return GetPointer<const apsi::fbs::BatchedPlaintextPolyn *>(VT_BATCHED_MATCHING_POLYN);
+  }
+  const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>> *felt_interp_polyns() const {
+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>> *>(VT_FELT_INTERP_POLYNS);
+  }
+  const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn>> *batched_interp_polyns() const {
+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn>> *>(VT_BATCHED_INTERP_POLYNS);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_FELT_MATCHING_POLYNS) &&
+           verifier.VerifyTable(felt_matching_polyns()) &&
+           VerifyOffsetRequired(verifier, VT_BATCHED_MATCHING_POLYN) &&
+           verifier.VerifyTable(batched_matching_polyn()) &&
+           VerifyOffset(verifier, VT_FELT_INTERP_POLYNS) &&
+           verifier.VerifyVector(felt_interp_polyns()) &&
+           verifier.VerifyVectorOfTables(felt_interp_polyns()) &&
+           VerifyOffset(verifier, VT_BATCHED_INTERP_POLYNS) &&
+           verifier.VerifyVector(batched_interp_polyns()) &&
+           verifier.VerifyVectorOfTables(batched_interp_polyns()) &&
+           verifier.EndTable();
+  }
+};
+
+struct BinBundleCacheBuilder {
+  typedef BinBundleCache Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_felt_matching_polyns(::flatbuffers::Offset<apsi::fbs::FEltMatrix> felt_matching_polyns) {
+    fbb_.AddOffset(BinBundleCache::VT_FELT_MATCHING_POLYNS, felt_matching_polyns);
+  }
+  void add_batched_matching_polyn(::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn> batched_matching_polyn) {
+    fbb_.AddOffset(BinBundleCache::VT_BATCHED_MATCHING_POLYN, batched_matching_polyn);
+  }
+  void add_felt_interp_polyns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>>> felt_interp_polyns) {
+    fbb_.AddOffset(BinBundleCache::VT_FELT_INTERP_POLYNS, felt_interp_polyns);
+  }
+  void add_batched_interp_polyns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn>>> batched_interp_polyns) {
+    fbb_.AddOffset(BinBundleCache::VT_BATCHED_INTERP_POLYNS, batched_interp_polyns);
+  }
+  explicit BinBundleCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<BinBundleCache> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<BinBundleCache>(end);
+    fbb_.Required(o, BinBundleCache::VT_FELT_MATCHING_POLYNS);
+    fbb_.Required(o, BinBundleCache::VT_BATCHED_MATCHING_POLYN);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<BinBundleCache> CreateBinBundleCache(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<apsi::fbs::FEltMatrix> felt_matching_polyns = 0,
+    ::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn> batched_matching_polyn = 0,
+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>>> felt_interp_polyns = 0,
+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn>>> batched_interp_polyns = 0) {
+  BinBundleCacheBuilder builder_(_fbb);
+  builder_.add_batched_interp_polyns(batched_interp_polyns);
+  builder_.add_felt_interp_polyns(felt_interp_polyns);
+  builder_.add_batched_matching_polyn(batched_matching_polyn);
+  builder_.add_felt_matching_polyns(felt_matching_polyns);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<BinBundleCache> CreateBinBundleCacheDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<apsi::fbs::FEltMatrix> felt_matching_polyns = 0,
+    ::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn> batched_matching_polyn = 0,
+    const std::vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>> *felt_interp_polyns = nullptr,
+    const std::vector<::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn>> *batched_interp_polyns = nullptr) {
+  auto felt_interp_polyns__ = felt_interp_polyns ? _fbb.CreateVector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>>(*felt_interp_polyns) : 0;
+  auto batched_interp_polyns__ = batched_interp_polyns ? _fbb.CreateVector<::flatbuffers::Offset<apsi::fbs::BatchedPlaintextPolyn>>(*batched_interp_polyns) : 0;
+  return apsi::fbs::CreateBinBundleCache(
+      _fbb,
+      felt_matching_polyns,
+      batched_matching_polyn,
+      felt_interp_polyns__,
+      batched_interp_polyns__);
+}
+
+struct BinBundle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef BinBundleBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BUNDLE_IDX = 4,
+    VT_MOD = 6,
+    VT_ITEM_BINS = 8,
+    VT_LABEL_BINS = 10,
+    VT_CACHE = 12,
+    VT_STRIPPED = 14
+  };
+  uint32_t bundle_idx() const {
+    return GetField<uint32_t>(VT_BUNDLE_IDX, 0);
+  }
+  uint64_t mod() const {
+    return GetField<uint64_t>(VT_MOD, 0);
+  }
+  const apsi::fbs::FEltMatrix *item_bins() const {
+    return GetPointer<const apsi::fbs::FEltMatrix *>(VT_ITEM_BINS);
+  }
+  const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>> *label_bins() const {
+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>> *>(VT_LABEL_BINS);
+  }
+  const apsi::fbs::BinBundleCache *cache() const {
+    return GetPointer<const apsi::fbs::BinBundleCache *>(VT_CACHE);
+  }
+  bool stripped() const {
+    return GetField<uint8_t>(VT_STRIPPED, 0) != 0;
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint32_t>(verifier, VT_BUNDLE_IDX, 4) &&
+           VerifyField<uint64_t>(verifier, VT_MOD, 8) &&
+           VerifyOffsetRequired(verifier, VT_ITEM_BINS) &&
+           verifier.VerifyTable(item_bins()) &&
+           VerifyOffset(verifier, VT_LABEL_BINS) &&
+           verifier.VerifyVector(label_bins()) &&
+           verifier.VerifyVectorOfTables(label_bins()) &&
+           VerifyOffset(verifier, VT_CACHE) &&
+           verifier.VerifyTable(cache()) &&
+           VerifyField<uint8_t>(verifier, VT_STRIPPED, 1) &&
+           verifier.EndTable();
+  }
+};
+
+struct BinBundleBuilder {
+  typedef BinBundle Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_bundle_idx(uint32_t bundle_idx) {
+    fbb_.AddElement<uint32_t>(BinBundle::VT_BUNDLE_IDX, bundle_idx, 0);
+  }
+  void add_mod(uint64_t mod) {
+    fbb_.AddElement<uint64_t>(BinBundle::VT_MOD, mod, 0);
+  }
+  void add_item_bins(::flatbuffers::Offset<apsi::fbs::FEltMatrix> item_bins) {
+    fbb_.AddOffset(BinBundle::VT_ITEM_BINS, item_bins);
+  }
+  void add_label_bins(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>>> label_bins) {
+    fbb_.AddOffset(BinBundle::VT_LABEL_BINS, label_bins);
+  }
+  void add_cache(::flatbuffers::Offset<apsi::fbs::BinBundleCache> cache) {
+    fbb_.AddOffset(BinBundle::VT_CACHE, cache);
+  }
+  void add_stripped(bool stripped) {
+    fbb_.AddElement<uint8_t>(BinBundle::VT_STRIPPED, static_cast<uint8_t>(stripped), 0);
+  }
+  explicit BinBundleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<BinBundle> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<BinBundle>(end);
+    fbb_.Required(o, BinBundle::VT_ITEM_BINS);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<BinBundle> CreateBinBundle(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint32_t bundle_idx = 0,
+    uint64_t mod = 0,
+    ::flatbuffers::Offset<apsi::fbs::FEltMatrix> item_bins = 0,
+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>>> label_bins = 0,
+    ::flatbuffers::Offset<apsi::fbs::BinBundleCache> cache = 0,
+    bool stripped = false) {
+  BinBundleBuilder builder_(_fbb);
+  builder_.add_mod(mod);
+  builder_.add_cache(cache);
+  builder_.add_label_bins(label_bins);
+  builder_.add_item_bins(item_bins);
+  builder_.add_bundle_idx(bundle_idx);
+  builder_.add_stripped(stripped);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<BinBundle> CreateBinBundleDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint32_t bundle_idx = 0,
+    uint64_t mod = 0,
+    ::flatbuffers::Offset<apsi::fbs::FEltMatrix> item_bins = 0,
+    const std::vector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>> *label_bins = nullptr,
+    ::flatbuffers::Offset<apsi::fbs::BinBundleCache> cache = 0,
+    bool stripped = false) {
+  auto label_bins__ = label_bins ? _fbb.CreateVector<::flatbuffers::Offset<apsi::fbs::FEltMatrix>>(*label_bins) : 0;
+  return apsi::fbs::CreateBinBundle(
+      _fbb,
+      bundle_idx,
+      mod,
+      item_bins,
+      label_bins__,
+      cache,
+      stripped);
+}
+
+inline const apsi::fbs::BinBundle *GetBinBundle(const void *buf) {
+  return ::flatbuffers::GetRoot<apsi::fbs::BinBundle>(buf);
+}
+
+inline const apsi::fbs::BinBundle *GetSizePrefixedBinBundle(const void *buf) {
+  return ::flatbuffers::GetSizePrefixedRoot<apsi::fbs::BinBundle>(buf);
+}
+
+inline bool VerifyBinBundleBuffer(
+    ::flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<apsi::fbs::BinBundle>(nullptr);
+}
+
+inline bool VerifySizePrefixedBinBundleBuffer(
+    ::flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<apsi::fbs::BinBundle>(nullptr);
+}
+
+inline void FinishBinBundleBuffer(
+    ::flatbuffers::FlatBufferBuilder &fbb,
+    ::flatbuffers::Offset<apsi::fbs::BinBundle> root) {
+  fbb.Finish(root);
+}
+
+inline void FinishSizePrefixedBinBundleBuffer(
+    ::flatbuffers::FlatBufferBuilder &fbb,
+    ::flatbuffers::Offset<apsi::fbs::BinBundle> root) {
+  fbb.FinishSizePrefixed(root);
+}
+
+}  // namespace fbs
+}  // namespace apsi
+
+#endif  // FLATBUFFERS_GENERATED_BINBUNDLE_APSI_FBS_H_
diff --git b/sender/apsi/util/cuckoo_filter_generated.h b/sender/apsi/util/cuckoo_filter_generated.h
new file mode 100644
index 0000000..2d2b2b7
--- /dev/null
+++ b/sender/apsi/util/cuckoo_filter_generated.h
@@ -0,0 +1,263 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_CUCKOOFILTER_APSI_FBS_H_
+#define FLATBUFFERS_GENERATED_CUCKOOFILTER_APSI_FBS_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+// Ensure the included flatbuffers.h is the same version as when this file was
+// generated, otherwise it may not be compatible.
+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
+              FLATBUFFERS_VERSION_MINOR == 3 &&
+              FLATBUFFERS_VERSION_REVISION == 3,
+             "Non-compatible flatbuffers version included");
+
+namespace apsi {
+namespace fbs {
+
+struct CuckooFilterOverflowCache;
+struct CuckooFilterOverflowCacheBuilder;
+
+struct CuckooFilterTable;
+struct CuckooFilterTableBuilder;
+
+struct CuckooFilter;
+struct CuckooFilterBuilder;
+
+struct CuckooFilterOverflowCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef CuckooFilterOverflowCacheBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_INDEX = 4,
+    VT_TAG = 6,
+    VT_USED = 8
+  };
+  uint64_t index() const {
+    return GetField<uint64_t>(VT_INDEX, 0);
+  }
+  uint64_t tag() const {
+    return GetField<uint64_t>(VT_TAG, 0);
+  }
+  bool used() const {
+    return GetField<uint8_t>(VT_USED, 0) != 0;
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint64_t>(verifier, VT_INDEX, 8) &&
+           VerifyField<uint64_t>(verifier, VT_TAG, 8) &&
+           VerifyField<uint8_t>(verifier, VT_USED, 1) &&
+           verifier.EndTable();
+  }
+};
+
+struct CuckooFilterOverflowCacheBuilder {
+  typedef CuckooFilterOverflowCache Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_index(uint64_t index) {
+    fbb_.AddElement<uint64_t>(CuckooFilterOverflowCache::VT_INDEX, index, 0);
+  }
+  void add_tag(uint64_t tag) {
+    fbb_.AddElement<uint64_t>(CuckooFilterOverflowCache::VT_TAG, tag, 0);
+  }
+  void add_used(bool used) {
+    fbb_.AddElement<uint8_t>(CuckooFilterOverflowCache::VT_USED, static_cast<uint8_t>(used), 0);
+  }
+  explicit CuckooFilterOverflowCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<CuckooFilterOverflowCache> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<CuckooFilterOverflowCache>(end);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<CuckooFilterOverflowCache> CreateCuckooFilterOverflowCache(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint64_t index = 0,
+    uint64_t tag = 0,
+    bool used = false) {
+  CuckooFilterOverflowCacheBuilder builder_(_fbb);
+  builder_.add_tag(tag);
+  builder_.add_index(index);
+  builder_.add_used(used);
+  return builder_.Finish();
+}
+
+struct CuckooFilterTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef CuckooFilterTableBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_BUCKETS = 4,
+    VT_BITS_PER_TAG = 6,
+    VT_TABLE = 8
+  };
+  uint64_t num_buckets() const {
+    return GetField<uint64_t>(VT_NUM_BUCKETS, 0);
+  }
+  uint64_t bits_per_tag() const {
+    return GetField<uint64_t>(VT_BITS_PER_TAG, 0);
+  }
+  const ::flatbuffers::Vector<uint64_t> *table() const {
+    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_TABLE);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint64_t>(verifier, VT_NUM_BUCKETS, 8) &&
+           VerifyField<uint64_t>(verifier, VT_BITS_PER_TAG, 8) &&
+           VerifyOffsetRequired(verifier, VT_TABLE) &&
+           verifier.VerifyVector(table()) &&
+           verifier.EndTable();
+  }
+};
+
+struct CuckooFilterTableBuilder {
+  typedef CuckooFilterTable Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_num_buckets(uint64_t num_buckets) {
+    fbb_.AddElement<uint64_t>(CuckooFilterTable::VT_NUM_BUCKETS, num_buckets, 0);
+  }
+  void add_bits_per_tag(uint64_t bits_per_tag) {
+    fbb_.AddElement<uint64_t>(CuckooFilterTable::VT_BITS_PER_TAG, bits_per_tag, 0);
+  }
+  void add_table(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> table) {
+    fbb_.AddOffset(CuckooFilterTable::VT_TABLE, table);
+  }
+  explicit CuckooFilterTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<CuckooFilterTable> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<CuckooFilterTable>(end);
+    fbb_.Required(o, CuckooFilterTable::VT_TABLE);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<CuckooFilterTable> CreateCuckooFilterTable(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint64_t num_buckets = 0,
+    uint64_t bits_per_tag = 0,
+    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> table = 0) {
+  CuckooFilterTableBuilder builder_(_fbb);
+  builder_.add_bits_per_tag(bits_per_tag);
+  builder_.add_num_buckets(num_buckets);
+  builder_.add_table(table);
+  return builder_.Finish();
+}
+
+inline ::flatbuffers::Offset<CuckooFilterTable> CreateCuckooFilterTableDirect(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    uint64_t num_buckets = 0,
+    uint64_t bits_per_tag = 0,
+    const std::vector<uint64_t> *table = nullptr) {
+  auto table__ = table ? _fbb.CreateVector<uint64_t>(*table) : 0;
+  return apsi::fbs::CreateCuckooFilterTable(
+      _fbb,
+      num_buckets,
+      bits_per_tag,
+      table__);
+}
+
+struct CuckooFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
+  typedef CuckooFilterBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TABLE = 4,
+    VT_NUM_ITEMS = 6,
+    VT_OVERFLOW = 8
+  };
+  const apsi::fbs::CuckooFilterTable *table() const {
+    return GetPointer<const apsi::fbs::CuckooFilterTable *>(VT_TABLE);
+  }
+  uint64_t num_items() const {
+    return GetField<uint64_t>(VT_NUM_ITEMS, 0);
+  }
+  const apsi::fbs::CuckooFilterOverflowCache *overflow() const {
+    return GetPointer<const apsi::fbs::CuckooFilterOverflowCache *>(VT_OVERFLOW);
+  }
+  bool Verify(::flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_TABLE) &&
+           verifier.VerifyTable(table()) &&
+           VerifyField<uint64_t>(verifier, VT_NUM_ITEMS, 8) &&
+           VerifyOffsetRequired(verifier, VT_OVERFLOW) &&
+           verifier.VerifyTable(overflow()) &&
+           verifier.EndTable();
+  }
+};
+
+struct CuckooFilterBuilder {
+  typedef CuckooFilter Table;
+  ::flatbuffers::FlatBufferBuilder &fbb_;
+  ::flatbuffers::uoffset_t start_;
+  void add_table(::flatbuffers::Offset<apsi::fbs::CuckooFilterTable> table) {
+    fbb_.AddOffset(CuckooFilter::VT_TABLE, table);
+  }
+  void add_num_items(uint64_t num_items) {
+    fbb_.AddElement<uint64_t>(CuckooFilter::VT_NUM_ITEMS, num_items, 0);
+  }
+  void add_overflow(::flatbuffers::Offset<apsi::fbs::CuckooFilterOverflowCache> overflow) {
+    fbb_.AddOffset(CuckooFilter::VT_OVERFLOW, overflow);
+  }
+  explicit CuckooFilterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  ::flatbuffers::Offset<CuckooFilter> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = ::flatbuffers::Offset<CuckooFilter>(end);
+    fbb_.Required(o, CuckooFilter::VT_TABLE);
+    fbb_.Required(o, CuckooFilter::VT_OVERFLOW);
+    return o;
+  }
+};
+
+inline ::flatbuffers::Offset<CuckooFilter> CreateCuckooFilter(
+    ::flatbuffers::FlatBufferBuilder &_fbb,
+    ::flatbuffers::Offset<apsi::fbs::CuckooFilterTable> table = 0,
+    uint64_t num_items = 0,
+    ::flatbuffers::Offset<apsi::fbs::CuckooFilterOverflowCache> overflow = 0) {
+  CuckooFilterBuilder builder_(_fbb);
+  builder_.add_num_items(num_items);
+  builder_.add_overflow(overflow);
+  builder_.add_table(table);
+  return builder_.Finish();
+}
+
+inline const apsi::fbs::CuckooFilter *GetCuckooFilter(const void *buf) {
+  return ::flatbuffers::GetRoot<apsi::fbs::CuckooFilter>(buf);
+}
+
+inline const apsi::fbs::CuckooFilter *GetSizePrefixedCuckooFilter(const void *buf) {
+  return ::flatbuffers::GetSizePrefixedRoot<apsi::fbs::CuckooFilter>(buf);
+}
+
+inline bool VerifyCuckooFilterBuffer(
+    ::flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<apsi::fbs::CuckooFilter>(nullptr);
+}
+
+inline bool VerifySizePrefixedCuckooFilterBuffer(
+    ::flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<apsi::fbs::CuckooFilter>(nullptr);
+}
+
+inline void FinishCuckooFilterBuffer(
+    ::flatbuffers::FlatBufferBuilder &fbb,
+    ::flatbuffers::Offset<apsi::fbs::CuckooFilter> root) {
+  fbb.Finish(root);
+}
+
+inline void FinishSizePrefixedCuckooFilterBuffer(
+    ::flatbuffers::FlatBufferBuilder &fbb,
+    ::flatbuffers::Offset<apsi::fbs::CuckooFilter> root) {
+  fbb.FinishSizePrefixed(root);
+}
+
+}  // namespace fbs
+}  // namespace apsi
+
+#endif  // FLATBUFFERS_GENERATED_CUCKOOFILTER_APSI_FBS_H_
